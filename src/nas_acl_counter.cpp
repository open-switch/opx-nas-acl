/*
 * Copyright (c) 2016 Dell Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
 * LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS
 * FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT.
 *
 * See the Apache Version 2.0 License for specific language governing
 * permissions and limitations under the License.
 */

/*
 * filename: nas_acl_counter.cpp
 */


/**
 * \file nas_acl_counter.cpp
 * \brief NAS ACL Counter Class implementation
 **/

#include "nas_acl_switch.h"
#include "nas_acl_counter.h"
#include "nas_acl_table.h"
#include "nas_acl_log.h"
#include <inttypes.h>

nas_acl_counter_t::nas_acl_counter_t (const nas_acl_table* table_p)
    :nas::base_obj_t (&(table_p->get_switch())), _table_p (table_p),
     _counter_name("")
{
}

nas_obj_id_t  nas_acl_counter_t::table_id() const noexcept
{
    return _table_p->table_id();
}

const char*  nas_acl_counter_t::table_name() const noexcept
{
    return _table_p->table_name();
}

void nas_acl_counter_t::copy_table_npus ()
{
    set_npu_list (get_table().npu_list());
    _following_table_npus = true;
}

void nas_acl_counter_t::add_npu (npu_id_t npu_id, bool reset)
{
    _following_table_npus = false;
    nas::base_obj_t::add_npu (npu_id, reset);
}

void nas_acl_counter_t::commit_create (bool rolling_back)
{
    if (_following_table_npus) {
        // A New Counter starts with _following_table_npus flag set
        // This flag is reset when the entry's NPUlist attribute is set
        // If no NPUs are set then copy all NPUs from table
        // Reset to the table NPU list
        copy_table_npus ();
    }

    nas::base_obj_t::commit_create (rolling_back);
}

void nas_acl_counter_t::diff_counter_type (nas_acl_counter_t& counter_orig)
{
    if (_enable_byte_count != counter_orig._enable_byte_count) {
        _types_to_be_pushed.insert (BASE_ACL_COUNTER_TYPE_BYTE);
    }

    if (_enable_pkt_count != counter_orig._enable_pkt_count) {
        _types_to_be_pushed.insert (BASE_ACL_COUNTER_TYPE_PACKET);
    }
}

nas::attr_set_t nas_acl_counter_t::commit_modify (base_obj_t& counter_orig,
                                                  bool rolling_back)
{
    if (!_following_table_npus &&
        nas::base_obj_t::npu_list().empty()) {
        // If all NPUs have been removed then copy all NPUs from table
        copy_table_npus();
    }

    diff_counter_type (dynamic_cast <nas_acl_counter_t&> (counter_orig));

    return nas::base_obj_t::commit_modify (counter_orig, rolling_back);
}

void nas_acl_counter_t::commit_delete (bool rolling_back)
{
    if (!_refs.empty ())
    {
        throw nas::base_exception {NAS_ACL_E_CREATE_ONLY,
                                   __PRETTY_FUNCTION__,
                                   "Cannot delete counter as it is still in use"};
    }

    nas::base_obj_t::commit_delete(rolling_back);
}

void nas_acl_counter_t::set_type(uint_t type, bool reset)
{
    auto t = static_cast <BASE_ACL_COUNTER_TYPE_t> (type);

    if (!is_attr_dirty (BASE_ACL_COUNTER_TYPES)) {
        mark_attr_dirty (BASE_ACL_COUNTER_TYPES);
        _types_to_be_pushed.clear();

        if (reset) {
            _enable_byte_count = false;
            _enable_pkt_count = false;
        }
    }

    switch (t) {
        case BASE_ACL_COUNTER_TYPE_PACKET:
            _enable_pkt_count = true;
            break;
        case BASE_ACL_COUNTER_TYPE_BYTE:
            _enable_byte_count = true;
            break;
        default:
            throw nas::base_exception {NAS_ACL_E_ATTR_VAL, __PRETTY_FUNCTION__,
                  std::string {"Unknown Counter type "}
                  + std::to_string (t)};
            break;
    }
}

void nas_acl_counter_t::set_counter_name(const char* name)
{
    _counter_name = name;
}

bool nas_acl_counter_t::push_create_obj_to_npu (npu_id_t npu_id,
                                                void* ndi_obj)
{
    ndi_obj_id_t ndi_cntr_id = 0;
    t_std_error rc = STD_ERR_OK;
    ndi_acl_counter_t ndi_counter = {0};

    ndi_counter.table_id = get_table().get_ndi_obj_id(npu_id);
    ndi_counter.enable_pkt_count = _enable_pkt_count;
    ndi_counter.enable_byte_count = _enable_byte_count;

    if ((rc = ndi_acl_counter_create (npu_id, &ndi_counter, &ndi_cntr_id))
            != STD_ERR_OK)
    {
        throw nas::base_exception {rc, __PRETTY_FUNCTION__,
                       std::string {"NDI Fail: counter Create Failed for NPU "}
                       + std::to_string (npu_id)};
    }
    // Cache the new counter ID generated by NDI
    _ndi_obj_ids[npu_id] = ndi_cntr_id;

    NAS_ACL_LOG_DETAIL ("Switch %d: Created ACL counter in NPU %d; NDI ID 0x%" PRIx64,
                        get_switch().id(), npu_id, ndi_cntr_id);

    return true;
}

bool nas_acl_counter_t::push_delete_obj_to_npu (npu_id_t npu_id)
{
    t_std_error rc = STD_ERR_OK;

    if ((rc = ndi_acl_counter_delete (npu_id, _ndi_obj_ids.at (npu_id)))
        != STD_ERR_OK)
    {
        throw nas::base_exception {rc, __PRETTY_FUNCTION__,
                                  std::string {"NDI Fail: Counter "}
                                  +    std::to_string (counter_id()) +
                                  std::string {" Delete Failed for NPU "}
                                  +    std::to_string (npu_id)};
    }

    NAS_ACL_LOG_DETAIL ("Switch %d: Deleted ACL counter %ld in NPU %d NDI-ID 0x%" PRIx64,
                        get_switch().id(), counter_id(), npu_id, _ndi_obj_ids.at (npu_id));

    _ndi_obj_ids.erase (npu_id);

    return true;
}

bool nas_acl_counter_t::_validate_entry_counter (counter c_type, npu_id_t npu_id,
                                                 ndi_obj_id_t *ndi_counter_id_p) const noexcept
{
    switch (c_type) {
        case counter::PKT:
            if (!is_pkt_count_enabled ()) {
                NAS_ACL_LOG_DETAIL ("Packet counter NOT enabled for counter %ld\n", counter_id());
                return false;
            }
            break;
        case counter::BYTE:
            if (!is_byte_count_enabled ()) {
                NAS_ACL_LOG_DETAIL ("Byte counter NOT enabled for counter %ld\n", counter_id());
                return false;
            }
            break;
    }

    auto it = _ndi_obj_ids.find (npu_id);
    if (it == _ndi_obj_ids.end()) {
        NAS_ACL_LOG_ERR ("ACL Counter %ld not available in this NPU %d\n",
                         counter_id(), npu_id);
        return false;
    }

    *ndi_counter_id_p = it->second;
    return true;
}

t_std_error nas_acl_counter_t::get_count_ndi (npu_id_t npu_id,
                                              bool& byte_count_valid,
                                              uint64_t* byte_count_p,
                                              bool& pkt_count_valid,
                                              uint64_t* pkt_count_p) const noexcept
{
    t_std_error rc = STD_ERR_OK;
    ndi_obj_id_t ndi_counter_id = 0;

    if (byte_count_p == nullptr || pkt_count_p == nullptr) {
        NAS_ACL_LOG_ERR("NULL pointer was not accepted as input argument");
        return NAS_ACL_E_ATTR_VAL;
    }

    byte_count_valid = _validate_entry_counter (counter::BYTE, npu_id, &ndi_counter_id);
    pkt_count_valid = _validate_entry_counter (counter::PKT, npu_id, &ndi_counter_id);

    if ((rc = ndi_acl_counter_get_count (npu_id, ndi_counter_id,
                                         byte_count_valid ? byte_count_p : nullptr,
                                         pkt_count_valid ? pkt_count_p : nullptr))
        != STD_ERR_OK) {

        NAS_ACL_LOG_ERR ("NDI Packet counter Get returned error %d for NPU %d\n",
                         rc, npu_id);
        return rc;
    }
    return NAS_ACL_E_NONE;
}

void nas_acl_counter_t::set_pkt_count_ndi (npu_id_t npu_id,
                                       uint64_t pkt_count) const
{
    t_std_error rc = STD_ERR_OK;
    ndi_obj_id_t ndi_counter_id = 0;

    if (!_validate_entry_counter (counter::PKT, npu_id, &ndi_counter_id)) {
        throw nas::base_exception {NAS_ACL_E_INCONSISTENT, __PRETTY_FUNCTION__,
            "Packet count action not enabled for this ACL Entry"};
    }

    if ((rc = ndi_acl_counter_set_pkt_count (npu_id, ndi_counter_id,
                                             pkt_count))
        != STD_ERR_OK) {

        throw nas::base_exception {rc, __PRETTY_FUNCTION__,
                    std::string {"NDI Packet counter Set failed for NPU "} +
                    std::to_string (npu_id)};
    }
}

void nas_acl_counter_t::set_byte_count_ndi (npu_id_t npu_id,
                                        uint64_t byte_count) const
{
    t_std_error rc = STD_ERR_OK;
    ndi_obj_id_t ndi_counter_id = 0;

    if (!_validate_entry_counter (counter::BYTE, npu_id, &ndi_counter_id)) {
        throw nas::base_exception {NAS_ACL_E_INCONSISTENT, __PRETTY_FUNCTION__,
            "Byte count action not enabled for this ACL Entry"};
    }

    if ((rc = ndi_acl_counter_set_byte_count (npu_id, ndi_counter_id,
                                              byte_count))
        != STD_ERR_OK) {

        throw nas::base_exception {rc, __PRETTY_FUNCTION__,
                    std::string {"NDI Byte counter Set failed for NPU "} +
                    std::to_string (npu_id)};
    }
}
